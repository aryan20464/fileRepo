âœ… 1. Check if Periodic Inactivity Check Is Running
In your ActivityMonitorService, update the handleInactivity() method:

ts
Copy
Edit
private handleInactivity() {
  const now = Date.now();
  const timeSinceLastActivity = now - this.lastActivity;
  const secondsIdle = Math.floor(timeSinceLastActivity / 1000);

  console.log(`[Session Check] ${new Date().toLocaleTimeString()} - Idle for ${secondsIdle} seconds`);

  if (timeSinceLastActivity < this.maxInactivity) {
    this.authService.refreshToken();
  } else {
    console.log(`[Logout Triggered] Inactive for ${secondsIdle} seconds`);
    this.authService.logout();
  }
}
âœ… Now youâ€™ll see a log every 2 mins (or whatever checkInterval is) even if user isnâ€™t doing anything.

âœ… 2. Log When Token Is Refreshed and Decoded Expiry Time
In your auth.service.ts, update refreshToken():

ts
Copy
Edit
refreshToken() {
  const refreshToken = this.getRefreshToken();
  if (!refreshToken) return;

  this.http.post<{ token: string }>(`${this.baseUrl}/refresh`, { refreshToken })
    .subscribe({
      next: res => {
        localStorage.setItem('token', res.token);

        try {
          const decoded: any = jwtDecode(res.token);
          const exp = decoded.exp;
          const expDate = new Date(exp * 1000);

          console.log(`[JWT Refresh] New token stored at ${new Date().toLocaleTimeString()}`);
          console.log(`[JWT Expiry] Token expires at ${expDate.toLocaleTimeString()}`);
        } catch (e) {
          console.warn('[JWT Decode Error]', e);
        }
      },
      error: () => this.logout()
    });
}
âœ… Youâ€™ll see:

csharp
Copy
Edit
[JWT Refresh] New token stored at 7:58:12 PM
[JWT Expiry] Token expires at 8:03:12 PM
âœ… 3. Optional: Log on Activity Events
In monitorUserActivity():

ts
Copy
Edit
private monitorUserActivity() {
  ['mousemove', 'keydown'].forEach(event =>
    document.addEventListener(event, () => {
      this.lastActivity = Date.now();
      console.log(`[Activity] ${event} at ${new Date(this.lastActivity).toLocaleTimeString()}`);
    })
  );
}
ðŸ§ª Result in Browser Console
Youâ€™ll now see logs like:

csharp
Copy
Edit
[Activity] keydown at 8:00:12 PM
[Session Check] 8:02:12 PM - Idle for 50 seconds
[JWT Refresh] New token stored at 8:02:12 PM
[JWT Expiry] Token expires at 8:07:12 PM
ðŸ› ï¸ Bonus: View Token Expiry Any Time in DevTools Console
If you expose a function in the window, you can debug easily:

ts
Copy
Edit
(window as any).printJwtExpiry = () => {
  const token = localStorage.getItem('token');
  if (!token) return console.log('No token');
  const decoded: any = jwtDecode(token);
  const exp = decoded.exp;
  console.log(`[Manual Check] Token expires at: ${new Date(exp * 1000).toLocaleTimeString()}`);
};
Now in browser console, just run:

js
Copy
Edit
printJwtExpiry()
âœ… Itâ€™ll print the JWT expiry any time manually.

Let me know if you want a visual countdown, or a warning popup when 1 minute remains before logout.









Ask ChatGPT



Tools















refreshToken() {
  const refreshToken = this.getRefreshToken();
  if (!refreshToken) return;

  this.http.post<{ token: string }>(`${this.baseUrl}/refresh`, { refreshToken })
    .subscribe({
      next: res => {
        localStorage.setItem('token', res.token);
        console.log(`[JWT Refresh] New token retrieved and stored at ${new Date().toLocaleTimeString()}`);
      },
      error: () => this.logout()
    });
}



private monitorUserActivity() {
  ['mousemove', 'keydown'].forEach(event =>
    document.addEventListener(event, () => {
      this.lastActivity = Date.now();
      console.log(`[Activity] ${event} at ${new Date(this.lastActivity).toLocaleTimeString()}`);
    })
  );
}


auth service 

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import jwtDecode from 'jwt-decode';

@Injectable({ providedIn: 'root' })
export class AuthService {
  private baseUrl = 'http://localhost:8080/api/auth';

  constructor(private http: HttpClient, private router: Router) {}

  login(credentials: { username: string, password: string }) {
    return this.http.post<{ token: string, refreshToken: string }>(`${this.baseUrl}/login`, credentials);
  }

  refreshToken() {
    const refreshToken = this.getRefreshToken();
    if (!refreshToken) return;

    this.http.post<{ token: string }>(`${this.baseUrl}/refresh`, { refreshToken })
      .subscribe({
        next: res => localStorage.setItem('token', res.token),
        error: () => this.logout()
      });
  }

  saveTokens(token: string, refreshToken: string) {
    localStorage.setItem('token', token);
    localStorage.setItem('refreshToken', refreshToken);
  }

  getToken(): string | null {
    return localStorage.getItem('token');
  }

  getRefreshToken(): string | null {
    return localStorage.getItem('refreshToken');
  }

  logout(): void {
    localStorage.removeItem('token');
    localStorage.removeItem('refreshToken');
    this.router.navigate(['/login']);
  }

  isTokenExpired(): boolean {
    const token = this.getToken();
    if (!token) return true;

    try {
      const decoded: any = jwtDecode(token);
      return decoded.exp < Date.now() / 1000;
    } catch {
      return true;
    }
  }
}


token interceptor 

import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';
import { AuthService } from '../services/auth.service';

@Injectable()
export class TokenInterceptor implements HttpInterceptor {
  constructor(private authService: AuthService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = this.authService.getToken();
    if (token) {
      req = req.clone({ headers: req.headers.set('Authorization', `Bearer ${token}`) });
    }
    return next.handle(req);
  }
}


auth guard

import { Injectable } from '@angular/core';
import { CanActivate, Router } from '@angular/router';
import { AuthService } from '../services/auth.service';

@Injectable({ providedIn: 'root' })
export class AuthGuard implements CanActivate {
  constructor(private authService: AuthService, private router: Router) {}

  canActivate(): boolean {
    if (!this.authService.isTokenExpired()) return true;
    this.authService.logout();
    return false;
  }
}


activity-monitor.service.ts

import { Injectable } from '@angular/core';
import { AuthService } from './auth.service';

@Injectable({ providedIn: 'root' })
export class ActivityMonitorService {
  private lastActivity = Date.now();
  private readonly checkInterval = 2 * 60 * 1000; // 2 mins
  private readonly maxInactivity = 5 * 60 * 1000; // 5 mins

  constructor(private authService: AuthService) {
    this.monitorUserActivity();
    setInterval(() => this.handleInactivity(), this.checkInterval);
  }

  private monitorUserActivity() {
    ['mousemove', 'keydown'].forEach(event =>
      document.addEventListener(event, () => this.lastActivity = Date.now())
    );
  }

  private handleInactivity() {
    const now = Date.now();
    if (now - this.lastActivity < this.maxInactivity) {
      this.authService.refreshToken(); // user is active, refresh session
    } else {
      this.authService.logout(); // user is inactive for too long
    }
  }
}
app component lo constructor(private activityMonitor: ActivityMonitorService) {}


Auth controller java

@RestController
@RequestMapping("/api/auth")
@RequiredArgsConstructor
public class AuthController {

    private final UserRepository userRepository;
    private final RefreshTokenRepository refreshTokenRepo;
    private final JwtUtil jwtUtil;
    private final RefreshTokenService refreshTokenService;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody AuthRequest request) {
        User user = userRepository.findByUsername(request.getUsername())
            .orElseThrow(() -> new RuntimeException("User not found"));

        if (!user.getPassword().equals(request.getPassword())) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        }

        String accessToken = jwtUtil.generateToken(user);
        String refreshToken = refreshTokenService.createRefreshToken(user);

        return ResponseEntity.ok(new AuthResponse(accessToken, refreshToken));
    }

    @PostMapping("/refresh")
    public ResponseEntity<?> refresh(@RequestBody TokenRefreshRequest request) {
        return refreshTokenService.findByToken(request.getRefreshToken())
            .map(refreshTokenService::verifyExpiration)
            .map(RefreshToken::getUser)
            .map(user -> {
                String token = jwtUtil.generateToken(user);
                return ResponseEntity.ok(new TokenRefreshResponse(token));
            })
            .orElseThrow(() -> new RuntimeException("Refresh token invalid"));
    }
}


refresh token service 

@Service
@RequiredArgsConstructor
public class RefreshTokenService {

    private final RefreshTokenRepository refreshTokenRepository;
    private final UserRepository userRepository;

    private final long refreshTokenDurationMs = 7 * 24 * 60 * 60 * 1000; // 7 days

    public String createRefreshToken(User user) {
        refreshTokenRepository.deleteByUser(user); // Remove old token

        RefreshToken token = RefreshToken.builder()
                .user(user)
                .token(UUID.randomUUID().toString())
                .expiryDate(Instant.now().plusMillis(refreshTokenDurationMs))
                .build();

        refreshTokenRepository.save(token);
        return token.getToken();
    }

    public Optional<RefreshToken> findByToken(String token) {
        return refreshTokenRepository.findByToken(token);
    }

    public RefreshToken verifyExpiration(RefreshToken token) {
        if (token.getExpiryDate().isBefore(Instant.now())) {
            refreshTokenRepository.delete(token);
            throw new RuntimeException("Refresh token expired");
        }
        return token;
    }
}


jwtutil 

@Component
public class JwtUtil {

    private final String SECRET = "my-secret-key";
    private final long EXPIRATION = 5 * 60 * 1000; // 5 min

    public String generateToken(User user) {
        return Jwts.builder()
                .setSubject(user.getUsername())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION))
                .signWith(SignatureAlgorithm.HS512, SECRET)
                .compact();
    }

    public String extractUsername(String token) {
        return Jwts.parser().setSigningKey(SECRET).parseClaimsJws(token).getBody().getSubject();
    }

    public boolean isTokenValid(String token) {
        try {
            Jwts.parser().setSigningKey(SECRET).parseClaimsJws(token);
            return true;
        } catch (JwtException e) {
            return false;
        }
    }
}



ðŸ§¾ DTOs
AuthRequest.java
java
Copy
Edit
@Data
public class AuthRequest {
    private String username;
    private String password;
}
AuthResponse.java
java
Copy
Edit
@Data
@AllArgsConstructor
public class AuthResponse {
    private String token;
    private String refreshToken;
}
TokenRefreshRequest.java
java
Copy
Edit
@Data
public class TokenRefreshRequest {
    private String refreshToken;
}
TokenRefreshResponse.java
java
Copy
Edit
@Data
@AllArgsConstructor
public class TokenRefreshResponse {
    private String token;
}



































import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule } from '@angular/forms';
import { AppComponent } from './app.component';
import { BrowserAnimationsModule } from '@angular/platform-browser/animations';

// Material Modules
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatNativeDateModule } from '@angular/material/core';
import { MatButtonModule } from '@angular/material/button';

@NgModule({
  declarations: [AppComponent],
  imports: [
    BrowserModule,
    FormsModule,
    BrowserAnimationsModule,
    MatFormFieldModule,
    MatInputModule,
    MatDatepickerModule,
    MatNativeDateModule,
    MatButtonModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule {}


<div class="container" style="margin: 2rem;">
  <h2>Date Range Picker</h2>

  <form (ngSubmit)="onSubmit()" #dateForm="ngForm">
    <mat-form-field appearance="fill">
      <mat-label>From Date</mat-label>
      <input matInput [matDatepicker]="picker1" [(ngModel)]="fromDate" name="fromDate" required>
      <mat-datepicker-toggle matSuffix [for]="picker1"></mat-datepicker-toggle>
      <mat-datepicker #picker1></mat-datepicker>
    </mat-form-field>

    <mat-form-field appearance="fill">
      <mat-label>To Date</mat-label>
      <input matInput [matDatepicker]="picker2" [(ngModel)]="toDate" name="toDate" required>
      <mat-datepicker-toggle matSuffix [for]="picker2"></mat-datepicker-toggle>
      <mat-datepicker #picker2></mat-datepicker>
    </mat-form-field>

    <button mat-raised-button color="primary" type="submit">Submit</button>
  </form>

  <div *ngIf="submitted" style="margin-top: 1rem;">
    <p><strong>From:</strong> {{ fromDate | date: 'mediumDate' }}</p>
    <p><strong>To:</strong> {{ toDate | date: 'mediumDate' }}</p>
  </div>
</div>


import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html'
})
export class AppComponent {
  fromDate!: Date;
  toDate!: Date;
  submitted = false;

  onSubmit() {
    this.submitted = true;
    console.log('From:', this.fromDate, 'To:', this.toDate);
  }
}
